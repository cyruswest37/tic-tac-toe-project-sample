# tic-tac-toe-project-sample
This is a sample from the command line tic-tac-toe game I created on a team with two other students using Visual Studio Code and the functional programming language OCaml.

The full project includes classic, AI, and ultimate modes, but for the sake of academic integrity I have only included a few files from the AI mode in this repository. The .ml and .mli files in this repository are almost exclusively my own work, including the documentation. The full project was around 1500 lines of code (not including documentation comments) and the members of my team and I contributed about equally (500 lines each) to the functional code in the project. Much of my contribution to the project was related to documentation and ensuring the entire project met the code quality standards of the course. My contributions to the full project included 42 commits (excluding merge commits), 2,859 insertions, and 2,071 deletions. My two partners contributions included 46 commits, 1640 insertions, 867 deletions, and 26 commits, 1071 insertions, and 767 deletions.

The .mli file contains declarations of the functions in the .ml file that are used by the main file in the full project. This file makes these functions and their documentation accessible in the main file of the full project.

The .ml file contains a set of functions that analyze and mark positions on the tic-tac-toe board in an attempt to prevent the player from marking three consecutive positions vertically, horizontally, or diagonally across the board. In the full project, the functions in this file are called from a main file to mark positions on the board after the player completes their turn.

It is possible to create a perfect tic-tac-toe AI using the minimax algorithm. My team and I decided against using the minimax algorithm because a game of tic-tac-toe against a perfect AI would at best result in a tie. We felt it would not be fun for the player if there was no possible way for them to win. Instead, I constructed the mode to have three different difficulty levels. At the lowest difficulty level, a random position is marked on the board. The second difficulty level is more complicated. There are two functions crnr_block and edge_block that seek to prevent the player from winning the game. The crnr_block function attempts to prevent the player from winning the game using the corners of the board. The edge_block function attempts to prevent the player from winning the game using the positions between the edges of the board. For either function a position is marked at random if the player is unable to win the game in their next turn. At difficult level two, one of these functions is chosen at random and is used for the duration of the game. At difficulty level three both functions are used with their priority chosen at random each turn. Using these functions, I created a single player mode that is fun for the player even at the highest difficulty level.
